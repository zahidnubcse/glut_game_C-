#include <GL/glut.h>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>

// Window size
int windowWidth = 800;
int windowHeight = 600;

// Game settings
const float PLAYER_SIZE = 18.0f;        // half-size of the square
const float PLAYER_SPEED = 120.0f;      // pixels per second
const float TELEPORT_COOLDOWN = 2.5f;   // seconds
const float SURVIVAL_TIME = 10.0f;      // seconds B must survive to win

// Utility
float clampf(float v, float a, float b) { return v < a ? a : (v > b ? b : v); }
float dist(float x1, float y1, float x2, float y2) {
    float dx = x1 - x2;
    float dy = y1 - y2;
    return sqrtf(dx*dx + dy*dy);
}

// Player struct
struct Square {
    float x, y;
    float halfSize;
    float rcol, gcol, bcol;
};
Square redPlayer, bluePlayer, greenPlayer;

// Input state (keyboard)
bool keyDown[256];
bool specialDown[256];

// Timing
int lastTimeMillis = 0;
float elapsedSinceStart = 0.0f;
float remainingSurvival = SURVIVAL_TIME;
float teleportCooldownRemaining = 0.0f;

// Game state
bool gameOver = false;
int winner = 0; // 1 = Player A (red/blue), 2 = Player B (green), 0 = ongoing

// Forward declarations
void resetGame();
void drawString(float x, float y, const char* s);
void drawSquare(const Square &s);
void renderScene();
void updateFrame(int value);

// Initialize players positions/colors
void initPlayers() {
    redPlayer.x = 100; redPlayer.y = 100; redPlayer.halfSize = PLAYER_SIZE;
    redPlayer.rcol = 1.0f; redPlayer.gcol = 0.0f; redPlayer.bcol = 0.0f;

    bluePlayer.x = 200; bluePlayer.y = 100; bluePlayer.halfSize = PLAYER_SIZE;
    bluePlayer.rcol = 0.0f; bluePlayer.gcol = 0.0f; bluePlayer.bcol = 1.0f;

    greenPlayer.x = 400; greenPlayer.y = 300; greenPlayer.halfSize = PLAYER_SIZE;
    greenPlayer.rcol = 0.1f; greenPlayer.gcol = 0.8f; greenPlayer.bcol = 0.1f;
}

// Draw a filled square
void drawSquare(const Square &s) {
    glBegin(GL_QUADS);
    glColor3f(s.rcol, s.gcol, s.bcol);
    glVertex2f(s.x - s.halfSize, s.y - s.halfSize);
    glVertex2f(s.x + s.halfSize, s.y - s.halfSize);
    glVertex2f(s.x + s.halfSize, s.y + s.halfSize);
    glVertex2f(s.x - s.halfSize, s.y + s.halfSize);
    glEnd();
}

// Draw text with GLUT bitmap
void drawString(float x, float y, const char* s) {
    glRasterPos2f(x, y);
    for (size_t i = 0; i < strlen(s); ++i) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, (int)s[i]);
    }
}

// Keyboard down
void keyDownFunc(unsigned char key, int x, int y) {
    keyDown[(unsigned char)key] = true;
    if (!gameOver) {
        // nothing else
    } else {
        if (key == 'r' || key == 'R') {
            resetGame();
        }
    }
}

// Keyboard up
void keyUpFunc(unsigned char key, int x, int y) {
    keyDown[(unsigned char)key] = false;
}

// Mouse click -> teleport if cooldown finished
void mouseFunc(int button, int state, int mx, int my) {
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN && !gameOver) {
        if (teleportCooldownRemaining <= 0.0001f) {
            float gx = (float)mx;
            float gy = (float)(windowHeight - my);
            gx = clampf(gx, greenPlayer.halfSize, windowWidth - greenPlayer.halfSize);
            gy = clampf(gy, greenPlayer.halfSize, windowHeight - greenPlayer.halfSize);
            greenPlayer.x = gx;
            greenPlayer.y = gy;
            teleportCooldownRemaining = TELEPORT_COOLDOWN;
        }
    }
}

// Window reshape
void reshapeFunc(int w, int h) {
    windowWidth = w;
    windowHeight = h;
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0.0, w, 0.0, h, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
}

// Reset everything
void resetGame() {
    initPlayers();
    elapsedSinceStart = 0.0f;
    remainingSurvival = SURVIVAL_TIME;
    teleportCooldownRemaining = 0.0f;
    gameOver = false;
    winner = 0;
    lastTimeMillis = glutGet(GLUT_ELAPSED_TIME);
}

// Update logic & physics
void updatePhysics(float dt) {
    // Move red with WASD
    float vxR = 0.0f, vyR = 0.0f;
    if (keyDown['w'] || keyDown['W']) vyR += 1.0f;
    if (keyDown['s'] || keyDown['S']) vyR -= 1.0f;
    if (keyDown['a'] || keyDown['A']) vxR -= 1.0f;
    if (keyDown['d'] || keyDown['D']) vxR += 1.0f;
    float mag = sqrtf(vxR*vxR + vyR*vyR);
    if (mag > 0.001f) { vxR /= mag; vyR /= mag; }
    redPlayer.x += vxR * PLAYER_SPEED * dt;
    redPlayer.y += vyR * PLAYER_SPEED * dt;

    // Move blue with IJKL
    float vxB = 0.0f, vyB = 0.0f;
    if (keyDown['i'] || keyDown['I']) vyB += 1.0f;
    if (keyDown['k'] || keyDown['K']) vyB -= 1.0f;
    if (keyDown['j'] || keyDown['J']) vxB -= 1.0f;
    if (keyDown['l'] || keyDown['L']) vxB += 1.0f;
    mag = sqrtf(vxB*vxB + vyB*vyB);
    if (mag > 0.001f) { vxB /= mag; vyB /= mag; }
    bluePlayer.x += vxB * PLAYER_SPEED * dt;
    bluePlayer.y += vyB * PLAYER_SPEED * dt;

    // clamp positions
    redPlayer.x = clampf(redPlayer.x, redPlayer.halfSize, windowWidth - redPlayer.halfSize);
    redPlayer.y = clampf(redPlayer.y, redPlayer.halfSize, windowHeight - redPlayer.halfSize);
    bluePlayer.x = clampf(bluePlayer.x, bluePlayer.halfSize, windowWidth - bluePlayer.halfSize);
    bluePlayer.y = clampf(bluePlayer.y, bluePlayer.halfSize, windowHeight - bluePlayer.halfSize);
    greenPlayer.x = clampf(greenPlayer.x, greenPlayer.halfSize, windowWidth - greenPlayer.halfSize);
    greenPlayer.y = clampf(greenPlayer.y, greenPlayer.halfSize, windowHeight - greenPlayer.halfSize);

    // cooldown timers
    if (teleportCooldownRemaining > 0.0f)
        teleportCooldownRemaining = clampf(teleportCooldownRemaining - dt, 0.0f, TELEPORT_COOLDOWN);

    // survival countdown
    remainingSurvival = clampf(remainingSurvival - dt, 0.0f, SURVIVAL_TIME);

    // collision check (square-square distance approximation = circle with radius = halfSize*sqrt(2))
    float radR = redPlayer.halfSize * 1.4142f;
    float radB = bluePlayer.halfSize * 1.4142f;
    float radG = greenPlayer.halfSize * 1.4142f;
    if (dist(redPlayer.x, redPlayer.y, greenPlayer.x, greenPlayer.y) <= radR + radG ||
        dist(bluePlayer.x, bluePlayer.y, greenPlayer.x, greenPlayer.y) <= radB + radG) {
        gameOver = true;
        winner = 1;
    }

    if (!gameOver && remainingSurvival <= 0.0001f) {
        gameOver = true;
        winner = 2;
    }
}

// Draw cooldown bar and timer UI
void drawUI() {
    char buf[128];
    snprintf(buf, sizeof(buf), "Time left for Green to survive: %.1f s", remainingSurvival);
    glColor3f(1,1,1);
    drawString(10.0f, windowHeight - 24.0f, buf);

    float barW = 200.0f;
    float barH = 18.0f;
    float barX = windowWidth - barW - 20.0f;
    float barY = windowHeight - 36.0f;

    glBegin(GL_QUADS);
      glColor3f(0.2f, 0.2f, 0.2f);
      glVertex2f(barX, barY);
      glVertex2f(barX + barW, barY);
      glVertex2f(barX + barW, barY + barH);
      glVertex2f(barX, barY + barH);
    glEnd();

    float t = (TELEPORT_COOLDOWN - teleportCooldownRemaining) / TELEPORT_COOLDOWN;
    t = clampf(t, 0.0f, 1.0f);
    float filled = barW * t;

    glBegin(GL_QUADS);
      glColor3f(0.1f, 0.8f, 0.4f);
      glVertex2f(barX, barY);
      glVertex2f(barX + filled, barY);
      glVertex2f(barX + filled, barY + barH);
      glVertex2f(barX, barY + barH);
    glEnd();

    if (teleportCooldownRemaining <= 0.001f) {
        drawString(barX + 6.0f, barY + 2.0f, "Teleport Ready (Click)");
    } else {
        char cbuf[64];
        snprintf(cbuf, sizeof(cbuf), "Teleport cooldown: %.1f s", teleportCooldownRemaining);
        drawString(barX + 6.0f, barY + 2.0f, cbuf);
    }

    drawString(10.0f, 18.0f, "Red: W A S D    Blue: I J K L    Green: Left Click (teleport)  R: Restart after game over");
}

// Display callback
void renderScene() {
    glClearColor(0.06f, 0.06f, 0.08f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    drawSquare(redPlayer);
    drawSquare(bluePlayer);
    drawSquare(greenPlayer);

    drawUI();

    if (gameOver) {
        glColor3f(1.0f, 1.0f, 0.6f);
        if (winner == 1) drawString(windowWidth*0.35f, windowHeight*0.5f + 10.0f, "PLAYER A WINS! (Red or Blue caught Green)");
        else if (winner == 2) drawString(windowWidth*0.35f, windowHeight*0.5f + 10.0f, "PLAYER B WINS! (Green survived)");
        drawString(windowWidth*0.35f, windowHeight*0.5f - 10.0f, "Press R to restart");
    }

    glutSwapBuffers();
}

// Timer / main loop
void updateFrame(int value) {
    int now = glutGet(GLUT_ELAPSED_TIME);
    if (lastTimeMillis == 0) lastTimeMillis = now;
    int delta = now - lastTimeMillis;
    lastTimeMillis = now;
    float dt = (float)delta / 1000.0f;
    if (dt > 0.1f) dt = 0.1f;

    if (!gameOver) {
        elapsedSinceStart += dt;
        updatePhysics(dt);
    }

    glutPostRedisplay();
    glutTimerFunc(16, updateFrame, 0);
}

int main(int argc, char** argv) {
    srand((unsigned int)time(nullptr));
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
    glutInitWindowSize(windowWidth, windowHeight);
    glutCreateWindow("Two-player OpenGL Game - Catch or Survive");

    initPlayers();

    glutDisplayFunc(renderScene);
    glutReshapeFunc(reshapeFunc);
    glutKeyboardFunc(keyDownFunc);
    glutKeyboardUpFunc(keyUpFunc);
    glutMouseFunc(mouseFunc);

    lastTimeMillis = glutGet(GLUT_ELAPSED_TIME);
    glutTimerFunc(16, updateFrame, 0);

    printf("Controls:\n");
    printf("Player A (two objects): Red -> W A S D, Blue -> I J K L\n");
    printf("Player B: Left mouse click to teleport (cooldown %.2f s)\n", TELEPORT_COOLDOWN);
    printf("Survival time required for Green to win: %.1f s\n", SURVIVAL_TIME);
    printf("Press R to restart after game over.\n");

    glutMainLoop();
    return 0;
}
